#!/bin/bash
# 
# Developed by Fred Weinhaus 11/11/2014 .......... revised 7/17/2020
#
# ------------------------------------------------------------------------------
# 
# Licensing:
# 
# Copyright © Fred Weinhaus
# 
# My scripts are available free of charge for non-commercial use, ONLY.
# 
# For use of my scripts in commercial (for-profit) environments or 
# non-free applications, please contact me (Fred Weinhaus) for 
# licensing arrangements. My email address is fmw at alink dot net.
# 
# If you: 1) redistribute, 2) incorporate any of these scripts into other 
# free applications or 3) reprogram them in another scripting language, 
# then you must contact me for permission, especially if the result might 
# be used in a commercial or for-profit environment.
# 
# My scripts are also subject, in a subordinate manner, to the ImageMagick 
# license, which can be found at: http://www.imagemagick.org/script/license.php
# 
# ------------------------------------------------------------------------------
# 
####
#
# USAGE: tshirtwarp lightingfile displacementfile infile backgroundfile [maskfile] outfile
# or
# USAGE: tshirtwarp datadirectory infile backgroundfile [maskfile] outfile
# 
# infile is the image to be placed onto the tshirt
# 
# backgroundfile is the tshirt image
# 
# maskfile is an optional mask image to limit the placement of the overlay image 
# on the tshirt.
# 
# lighting file and displacement file are generated by the script tshirt with 
# the -E option.
# 
# datadirectory is specified and/or created by the tshirt script and will contain 
# the lighting file, dispacement file and textfile of arguments named tshirtdata.txt 
# exported using the -E and -D directory options.
# 
# 
###
# 
# NAME: TSHIRTWARP 
# 
# PURPOSE: To apply an image to a region of of a tshirt image using a lighting
# file, a displacement map and arguments provided by the script tshirt.
# 
# DESCRIPTION: TSHIRTWARP applies an image to a region of a tshirt image 
# using a lighting file, a displacement map and arguments provided by the 
# script tshirt. The arguments must be copied from the tshirt script output 
# at the terminal and pasted in the arguments section of this script, if no directory 
# file was specified during the running of the tshirt script. If a directory was 
# specified, then all the images and textual data will be written to that directory 
# and only the directory needs to be specified with the infile and backgroundfile and 
# outfile. The latter mode with the directory permits one tshirtwarp script to be used 
# with all style tshirts, rather than save a customized script for each style tshirt.
# 
# REQUIREMENTS: IM 6.3.6-0 due to the use of the current control point 
# ordering. Also requires the preprocessing of the tshirt script in export 
# mode (-E) to get the lighting image (lighting.png), the displacement image 
# (displace.png) and to get the needed internal arguments that must be pasted 
# in this script below.
# 
# CAVEAT: No guarantee that this script will work on all platforms, 
# nor that trapping of inconsistent parameters is complete and 
# foolproof. Use At Your Own Risk. 
# 
######
# 

# get arguments
numargs=$#
maskfile=""
# test if first argument a directory
if [ -d "$1" -a ! -r "$1" ]; then
	echo "--- DIRECTORY IS NOT READABLE ---"
	exit 1
fi
if [ -d "$1" -a ! -s "$1" ]; then
	echo "--- DIRECTORY IS EMPTY ---"
	exit 1
fi
if [ -d "$1" -a -r "$1" -a -s "$1" ]; then
	# directory exists, is readable and is not empty
	if [ $# -eq 4 ]; then
		# directory file specified, which contains all needed files
		directory="$1"						# directory containing all needed images and text file
		infile="$2"							# input image
		bgfile="$3"							# background (tshirt) image
		outfile="$4"						# output image
		lfile="$directory/lighting.png"		# lighting image
		dfile="$directory/displace.png"		# dispacement image
		source $directory/tshirtdata.txt	# (source) reads and executes commands from given FILENAME and return
	elif [ $# -eq 5 ]; then
		# directory file specified, which contains all needed files
		directory="$1"						# directory containing all needed images and text file
		infile="$2"							# input image
		bgfile="$3"							# background (tshirt) image
		maskfile="$4"						# mask file
		outfile="$5"						# output image
		lfile="$directory/lighting.png"		# lighting image
		dfile="$directory/displace.png"		# dispacement image
		source $directory/tshirtdata.txt	# (source) reads and executes commands from given FILENAME and return
	else
		echo "--- INCONSISTENT NUMBER OF INPUT AND OUTPUT IMAGES SPECIFIED ---"
		exit 1
	fi
else
	if [ $# -eq 5 ]; then
		# no directory file specified and lighting and displacement files provided
		lfile="$1"			# lighting image
		dfile="$2"			# dispacement image
		infile="$3"			# input image
		bgfile="$4"			# background image
		outfile="$5"		# output image
	elif [ $# -eq 6 ]; then
		# no directory file specified and lighting and displacement files provided
		lfile="$1"			# lighting image
		dfile="$2"			# dispacement image
		infile="$3"			# input image
		maskfile="$4"		# mask file
		bgfile="$5"			# background image
		outfile="$6"		# output image
	else
		echo "--- INCONSISTENT NUMBER OF INPUT AND OUTPUT IMAGES SPECIFIED ---"
		exit 1
	fi
fi
	
#### -------------------------------------------------------------------------------------
#### SET INTERNAL ARGUMENTS HERE (PASTED FROM THE OUTPUT OF TSHIRT SCRIPT TO THE TERMINAL)
#### ONLY IF NO DIRECTORY PROVIDED





#### END INTERNAL ARGUMENTS
#### -------------------------------------------------------------------------------------


# test that lfile provided
if [ "$lfile" = "" ]; then 
	echo "INSUFFICIENT NUMBER OF FILES SPECIFIED"
	exit 1
fi

# test that dfile provided
if [ "$dfile" = "" ]; then 
	echo "INSUFFICIENT NUMBER OF FILES SPECIFIED"
	exit 1
fi

# test that infile provided
if [ "$infile" = "" ]; then 
	echo "INSUFFICIENT NUMBER OF FILES SPECIFIED"
	exit 1
fi

# test that bgfile provided
if [ "$bgfile" = "" ]; then 
	echo "INSUFFICIENT NUMBER OF FILES SPECIFIED"
	exit 1
fi

# test that outfile provided
if [ "$outfile" = "" ]; then
	echo "INSUFFICIENT NUMBER OF FILES SPECIFIED"
	exit 1
fi

# set directory for temporary files
tmpdir="/tmp"

dir="$tmpdir/TSHIRT.$$"
mkdir "$dir" || {
  echo >&2 "UNABLE TO CREATE WORKING DIR \"$dir\" -- ABORTING"
  exit 10
}
trap "rm -rf $dir;" 0
trap "rm -rf $dir; exit 1" 1 2 3 10 15
trap "rm -rf $dir; exit 1" ERR

# read lfile image
if ! convert -quiet "$lfile" +repage $dir/tmpL.miff; then
	echo "--- FILE $lfile DOES NOT EXIST OR IS NOT AN ORDINARY FILE, NOT READABLE OR HAS ZERO SIZE ---"
	exit 1
fi	

# read dfile image
if ! convert -quiet "$dfile" +repage $dir/tmpD.miff; then
	echo "--- FILE $dfile DOES NOT EXIST OR IS NOT AN ORDINARY FILE, NOT READABLE OR HAS ZERO SIZE ---"
	exit 1
fi	

# read infile image
if ! convert -quiet "$infile" +repage $modulating $dir/tmpI.miff; then
	echo "--- FILE $infile DOES NOT EXIST OR IS NOT AN ORDINARY FILE, NOT READABLE OR HAS ZERO SIZE ---"
	exit 1
fi	

# read bgfile (tshirt) image and make color (so that result is not grayscale when overlay image is grayscale)
if ! convert -quiet "$bgfile" +repage -colorspace sRGB $dir/tmpT.miff; then
	echo "--- FILE $infile DOES NOT EXIST OR IS NOT AN ORDINARY FILE, NOT READABLE OR HAS ZERO SIZE ---"
	exit 1
fi	

if [ "$maskfile" != "" ]; then
	# read maskfile image
	if ! convert -quiet "$maskfile" +repage $dir/tmpM.miff; then
		echo "--- FILE $maskfile DOES NOT EXIST OR IS NOT AN ORDINARY FILE, NOT READABLE OR HAS ZERO SIZE ---"
	fi	
fi

im_version=`convert -list configure | \
	sed '/^LIB_VERSION_NUMBER */!d; s//,/;  s/,/,0/g;  s/,0*\([0-9][0-9]\)/\1/g' | head -n 1`

if [ "$im_version" -ge "07000000" ]; then
	identifying="magick identify"
else
	identifying="identify"
fi

# get tshirt region corner coordinates and separate into x,y values
# tshirt coordinates are the even elements in coordinates
# overlay coordinates are the odd elements in the array
# re-compute overlay image coordinates below
ptArr=($coordinates)
num_pts=${#ptArr[*]}
if [ $num_pts -ne 8 ]; then 
	echo "--- INVALID NUMBER OF COORDINATES ---"
	exit 1
fi
for ((i=0; i<4; i++)); do
	j=$((2*i+1))
	xptArr[$i]=`echo ${ptArr[$j]} | cut -d, -f1`
	yptArr[$i]=`echo ${ptArr[$j]} | cut -d, -f2`
done

x1=${xptArr[0]}
y1=${yptArr[0]}
x2=${xptArr[1]}
y2=${yptArr[1]}
x3=${xptArr[2]}
y3=${yptArr[2]}
x4=${xptArr[3]}
y4=${yptArr[3]}
#echo "$x1,$y1 $x2,$y2 $x3,$y3 $x4,$y4"

# get width and height of overlay image and compute scale factor to fit region
ww=`convert -ping $dir/tmpI.miff -format "%w" info:`
hh=`convert -ping $dir/tmpI.miff -format "%h" info:`
# distort does not need scale to be computed. Perspective distort will do that.
if [ "$fit" = "scale" ]; then
	if [ $hh -ge $ww ]; then
		scale=`convert xc: -format "%[fx:($hh-1)/($leftheight-1)]" info:`
	else
		scale=`convert xc: -format "%[fx:($ww-1)/($topwidth-1)]" info:`
	fi
elif [ "$fit" = "top" ]; then
	xscale=`convert xc: -format "%[fx:($ww-1)/($topwidth-1)]" info:`
	yscale=`convert xc: -format "%[fx:($hh-1)/($leftheight-1)]" info:`
	scale=`convert xc: -format "%[fx:$xscale>$yscale?$xscale:$yscale]" info:`
	scaleflag=`convert xc: -format "%[fx:$xscale>$yscale?1:0]" info:`
	[ $scaleflag -eq 1 ] && scaleflag="x" || scaleflag="y"
elif [ "$fit" = "crop" -o "$fit" = "none" ]; then
	scale=`convert xc: -format "%[fx:($ww-1)/($topwidth-1)]" info:`
fi
#echo "scale=$scale; ww=$ww; hh=$hh;"

# compute overlay image coordinates from tshirt coordinates and fit and scale
# subtract offset and unrotate
# xoffset and yoffset are likely 0?
xoffset=0
yoffset=0
xo1=`convert xc: -format "%[fx:round(($x1-$xoffset)*cos($angle)+($y1-$yoffset)*sin($angle))]" info:`
yo1=`convert xc: -format "%[fx:round(($x1-$xoffset)*sin($angle)+($y1-$yoffset)*cos($angle))]" info:`
xo2=`convert xc: -format "%[fx:round(($x2-$xoffset)*cos($angle)+($y2-$yoffset)*sin($angle))]" info:`
yo2=`convert xc: -format "%[fx:round(($x2-$xoffset)*sin($angle)+($y2-$yoffset)*cos($angle))]" info:`
xo3=`convert xc: -format "%[fx:round(($x3-$xoffset)*cos($angle)+($y3-$yoffset)*sin($angle))]" info:`
yo3=`convert xc: -format "%[fx:round(($x3-$xoffset)*sin($angle)+($y3-$yoffset)*cos($angle))]" info:`
xo4=`convert xc: -format "%[fx:round(($x4-$xoffset)*cos($angle)+($y4-$yoffset)*sin($angle))]" info:`
yo4=`convert xc: -format "%[fx:round(($x4-$xoffset)*sin($angle)+($y4-$yoffset)*cos($angle))]" info:`
# compute max width and height
# error fixed below 3/19/2020 wo=`convert xc: -format "%[fx:max($xo4-$xo1,$xo3-$xo2)+1]" info:`
wo=`convert xc: -format "%[fx:max($xo2-$xo1,$xo4-$xo3)+1]" info:`
ho=`convert xc: -format "%[fx:max($yo4-$yo1,$yo3-$yo2)+1]" info:`
#echo "xoffset=$xoffset; yoffset=$yoffset; angle=$angle; wo=$wo; ho=$ho;"
if [ "$fit" = "distort" ]; then
	xo1=0
	yo1=0
	xo2=$((ww-1))
	yo2=$yo1
	xo3=$xo2
	yo3=$((hh-1))
	xo4=$xo1
	yo4=$yo3
elif [ "$fit" = "scale" ]; then
	if [ $hh -ge $ww ]; then
		xo1=`convert xc: -format "%[fx:round(0.5*($ww-$scale*$wo))]" info:`
		yo1=0
		xo2=`convert xc: -format "%[fx:(round($xo1+$scale*$wo-1))]" info:`
		yo2=$yo1
		xo3=$xo2
		yo3=`convert xc: -format "%[fx:(round($yo1+$scale*$ho-1))]" info:`
		xo4=$xo1
		yo4=$yo3
	else
		xo1=0
		yo1=`convert xc: -format "%[fx:round(0.5*($hh-$scale*$ho))]" info:`
		xo2=`convert xc: -format "%[fx:(round($xo1+$scale*$wo-1))]" info:`
		yo2=$yo1
		xo3=$xo2
		yo3=`convert xc: -format "%[fx:(round($yo1+$scale*$ho-1))]" info:`
		xo4=$xo1
		yo4=$yo3
	fi
	elif [ "$fit" = "top" ]; then
		if [ "$scaleflag" = "y" ]; then
			xo1=`convert xc: -format "%[fx:round(0.5*($ww-$scale*$wo))]" info:`
			yo1=0
			xo2=`convert xc: -format "%[fx:(round($xo1+$scale*$wo-1))]" info:`
			yo2=$yo1
			xo3=$xo2
			yo3=`convert xc: -format "%[fx:(round($yo1+$scale*$ho-1))]" info:`
			xo4=$xo1
			yo4=$yo3
		else
			xo1=0
			# center
			#yo1=`convert xc: -format "%[fx:round(0.5*($hh-$scale*$ht))]" info:`
			yo1=0
			xo2=`convert xc: -format "%[fx:(round($xo1+$scale*$wo-1))]" info:`
			yo2=$yo1
			xo3=$xo2
			yo3=`convert xc: -format "%[fx:(round($yo1+$scale*$ho-1))]" info:`
			xo4=$xo1
			yo4=$yo3
		fi
elif [ "$fit" = "crop" -o "$fit" = "none" ]; then
	xo1=0
	yo1=0
	xo2=$((ww-1))
	yo2=$yo1
	xo3=$xo2
	yo3=`convert xc: -format "%[fx:(round($scale*$ho-1))]" info:`
	xo4=$xo1
	yo4=$yo3
fi
#echo "$xo1,$yo1;  $xo2,$yo2;  $xo3,$yo3;  $xo4,$yo4;"

# define coordinate pairs for perspective transform
coordinates="$xo1,$yo1 $x1,$y1 $xo2,$yo2 $x2,$y2 $xo3,$yo3 $x3,$y3 $xo4,$yo4 $x4,$y4"
#echo "$coordinates"

# test if tshirt/bgfile has alpha. If so remove and save for later.
is_alpha=`$identifying -verbose $bgfile | grep "Alpha" | head -n 1`
[ "$is_alpha" != "" ] && convert $dir/tmpT.miff -alpha extract -blur 0x$antialias -level 50x100% $dir/tmpA.miff


# set up for sharpening
if [ "$sharpen" != "0" ]; then
	sproc="-unsharp 0x$sharpen -clamp"
else
	sproc=""
fi

# set up swapping for -C over
if [ "$compose" = "over" ]; then
	swapping="+swap"
else
	swapping=""
fi

# set up for opacity
if [ "$opacity" != "100" ]; then
	opacity=`convert xc: -format "%[fx:$opacity/100]" info:`
	oproc="-alpha on -channel a -evaluate multiply $opacity +channel"
else
	oproc=""
fi


if [ "$maskfile" != "" ]; then
	mask="$dir/tmpM.miff"
else
	mask=""
fi

# process image
if [ "$is_alpha" != "" ]; then
	# line2 1-3:   process overlay image to perspective transform with transparent
	#              background the size of the tshirt image and sharpen
	# lines 4-6:   apply lighting image 
	# lines 7-8:   apply displacement image
	# lines 9-11:  composite transformed overlay image onto tshirt image 
	#              and add back alpha channel
	# note: IM 7 needs -respect-parenthesis to that -compose copy_opacity following tmpL works properly, 
	# but IM 6 does not.
	# note: need to add -colorspace sRGB to tmpTG to keep tmpI as color after layers merge 7/17/2020 some time after 7.0.8.23
	convert -respect-parenthesis \( $dir/tmpT.miff -alpha transparent -colorspace sRGB \) \
		\( $dir/tmpI.miff -virtual-pixel none +distort perspective "$coordinates" $sproc \) \
		-background none -layers merge +repage \
		\
		\( -clone 0 -alpha extract \) \
		\( -clone 0 $oproc \( $dir/tmpL.miff \) $swapping -alpha off -compose $compose -composite \) \
		-delete 0 +swap -compose over -alpha off -compose copy_opacity -composite \
		\
		$dir/tmpD.miff \
		-define compose:args=-$displace,-$displace -compose displace -composite \
		\
		$dir/tmpT.miff +swap $mask -compose over -composite \
		$dir/tmpA.miff -alpha off -compose copy_opacity -composite "$outfile"

else
	# line2 1-3:   process overlay image to perspective transform with transparent
	#              background the size of the tshirt image and sharpen
	# lines 4-6:   apply lighting image 
	# lines 7-8:   apply displacement image
	# line 9:      composite transformed overlay image onto tshirt image 
	convert -respect-parenthesis \( $dir/tmpT.miff -alpha transparent \) \
		\( $dir/tmpI.miff -virtual-pixel none +distort perspective "$coordinates" $sproc \) \
		-background none -layers merge +repage \
		\
		\( -clone 0 -alpha extract \) \
		\( -clone 0 $oproc \( $dir/tmpL.miff \) $swapping -compose $compose -composite \) \
		-delete 0 +swap -compose over -alpha off -compose copy_opacity -composite \
		\
		$dir/tmpD.miff \
		-define compose:args=-$displace,-$displace -compose displace -composite \
		\
		$dir/tmpT.miff +swap $mask -compose over -composite "$outfile"
fi

exit 0
